1(a). In the code snippet DFS traversal is used to topologicaly sort the graph. here the only diffrence is that the output_list is populated after when the recursive call is finshed. And here every vertex of the graph acts as the source recusively. an extra list is cycle_check is used to check if there is any cycle in the graph. Appended every vertex visited to the cycle_check in the staring than if the neighbor vertex is already in the graph than the code exit and print impossible other wise the code will run and sort the graph topologicaly. the time complexity will be O(V+E) , V= number of Vertex, E= Number of edges

1(b). In the code snippet BFS traversal is used to topologicaly sort the graph. Here we have calculated the in degree edges of every vertex . and than we populated the queue if the indegree edge of a vertex is 0. and we have iteratively reduced the indgree counter of every vertex when it is visited every time. that is how we got the topologicaly sorted graph at the end.the time complexity will be O(V+E) , V= number of Vertex, E= Number of edges

2. This code snippet is exactly same as 1(b). Just i have made an extra function Queue_sort to sort the Queue. It will make it to choose the lexicographically smallest valid course. the time complexity will be O(V+E) , V= number of Vertex, E= Number of edges

3.In the code snippet i have used kosaraju's algorithm to find strongly connected componenets. Where firstly i have defined a normal DFS function. than defined a function named PDFS which will a sorted list according to the end time of the traversal. The tranform function will reverse the directions of the graph. Than the ultimate function kosaraju where first the PDFS function is called which gives a sorted array. than taking the elements of the sorted list(priority) as source we will run DFS over the reversed graph which will ultimately give us the strongly connected componenets.the time complexity will be O(V+E) , V= number of Vertex, E= Number of edges