Task 1(a): The code snippet represents a weighted graph in as a adjacency matrix. First it takes a 2D matrix according the size of the vertex of the graphs. By using for loop we will append the value of the weight of each node adjacent to each other in the nested list(matrix). because , it uses one for loop that's why the time complexity of this task will be O(n), where n is the number of edges of the graph.

Task 1(b): The code snippet rep,esents a weighted graph in as a adjacency list. First it takes a nested list according the size of the vertex of the graphs. By using for loop, we will append the value of the weight of the node and the adjacent node by making them a tuple, it uses one for loop that's why the time complexity of this task will be O(n), where n is the number of edges of the graph.

Task 2: The code snippet represents the BFS traversal of graph. First imported "Queue" from queue module. Than created a adjacency list and populated it. "color" is teken as initialized as value "0" to check if every node is visited or not.A function named 'Bfs' is being defined, where adjacency list and source vertex is the parameter. Inside the funtion, enqueue the starting vertex and append it to the output list. Than ran the loop until the queue is empty than again ran a inner loop to itearate over the adjacent values in the graph. If a neighbor is not visited, mark it as visited, enqueue it, and append it to the output list. Than after printing output_list we will get the BFS traversal of the graph. As, we are using nested loop the time complexity will be, O(n**2)

Task 3:The code snippet represents the DFS traversal of graph. First adjacency matrix is created and being popolated.Than a list named "color" is taken initialized as "0" to check if the function is visited or not.  Than a funtion is defined named "DFS" which takes adjacency list and source of the traversal as parameters.  Inside the DFS function, marked the corresponding index of the "color" list from 0 to 1 and to mark it as visited and append it in the output_list. than recursively called the DFS function for each unvisited adjacent vertex of the current vertex. At last the output_list will give us the final traversal of the graph. Only one loop have been used that's why the time complexity of the code snippet will be O(n), n is the number of Verteces.

Task 4: The code snippet represents the Cycle detection of a graph. It is the exactly same code as the DFS traversal but with a slight change. An extra global variable os taken named "flag" to track if the graph is cycle or not. If we find the same unvisited vertex in the graph the flag variable will be true which we indicate the cycle in the graph.the time complexity will be O(n), where n is the number of vertices.

Task 5: The code snippet finds the shortest path and minimum time from the source vertex to the speicified destination vertex. he BFS traversal keeps track of the current path from the source vertex to each visited vertex. When the destination vertex is reached, the code calculates and outputs the minimum time (number of edges) and the corresponding shortest path. The time complexity will be O(n), where n is the number of vertices.

Task 6: The code snippet counts the maximum number of D from a 2D matrix using DFS.It reads the dimensions of a 2D grid from an input file and populates an adjacency matrix (adj_matrix) representing the grid. It initializes a 2D array color to track visited cells and sets count and answer to 0 and negative infinity, respectively. The dfs_visit function iterates through each cell, initiating a DFS from unvisited "D" cells and updating the count based on the connected region. The valid_index function checks if a cell index is within grid bounds. The DFS function recursively explores neighboring cells, incrementing the count for "D" cells. After exploring the entire grid, the code writes the maximum count of consecutive "D" cells (answer) to an output file. The time complexity is O(n * m), where n and m are the grid dimensions.